/**
        const settings = await this.getSettings();
        if (!settings || Object.keys(settings).length === 0) {
            await this.saveSettings(this.DEFAULT_SETTINGS);
        }
    },

    /**
     * Get user settings
     */
    async getSettings() {
    try {
        const result = await chrome.storage.sync.get(this.KEYS.SETTINGS);
        return result[this.KEYS.SETTINGS] || this.DEFAULT_SETTINGS;
    } catch (error) {
    async saveActivityChunk(chunk) {
            try {
                const result = await chrome.storage.local.get(this.KEYS.ACTIVITY_DATA);
                const activityData = result[this.KEYS.ACTIVITY_DATA] || [];

                // Add new chunk
                activityData.push(chunk);

                // Sort by timestamp
                activityData.sort((a, b) => a.timestamp - b.timestamp);

                await chrome.storage.local.set({ [this.KEYS.ACTIVITY_DATA]: activityData });
                return true;
            } catch (error) {
                console.error('Error saving activity chunk:', error);
                return false;
            }
        },

    /**
     * Get activity data for a date range
     * @param {number} startTime - Start timestamp (ms)
     * @param {number} endTime - End timestamp (ms)
     */
    async getActivityData(startTime, endTime) {
            try {
                const result = await chrome.storage.local.get(this.KEYS.ACTIVITY_DATA);
                const activityData = result[this.KEYS.ACTIVITY_DATA] || [];

                if (!startTime && !endTime) {
                    return activityData;
                }

                return activityData.filter(chunk => {
                    if (startTime && chunk.timestamp < startTime) return false;
                    if (endTime && chunk.timestamp > endTime) return false;
                    return true;
                });
            } catch (error) {
                console.error('Error getting activity data:', error);
                return [];
            }
        },

    /**
     * Clean up old data based on retention settings
     */
    async cleanupOldData() {
            try {
                const settings = await this.getSettings();
                const retentionMs = settings.retentionDays * 24 * 60 * 60 * 1000;
                const cutoffTime = Date.now() - retentionMs;

                const result = await chrome.storage.local.get(this.KEYS.ACTIVITY_DATA);
                const activityData = result[this.KEYS.ACTIVITY_DATA] || [];

                const filteredData = activityData.filter(chunk => chunk.timestamp >= cutoffTime);

                await chrome.storage.local.set({ [this.KEYS.ACTIVITY_DATA]: filteredData });

                const removed = activityData.length - filteredData.length;
                console.log(`Cleaned up ${removed} old activity chunks`);
                return removed;
            } catch (error) {
                console.error('Error cleaning up old data:', error);
                return 0;
            }
        },

    /**
     * Export all data as JSON
     */
    async exportData() {
            try {
                const settings = await this.getSettings();
                const activityData = await this.getActivityData();

                const exportObject = {
                    version: '1.0',
                    exportDate: new Date().toISOString(),
                    settings: {
                        chunkDuration: settings.chunkDuration,
                        idleThreshold: settings.idleThreshold
                    },
                    activityData: activityData
                };

                return exportObject;
            } catch (error) {
                console.error('Error exporting data:', error);
                return null;
            }
        },

    /**
     * Import and merge data from JSON
     * @param {Object} importData - Exported data object
     * @param {boolean} merge - If true, merge with existing data; if false, replace
     */
    async importData(importData, merge = true) {
            try {
                // Validate import data
                if (!importData.version || !importData.activityData) {
                    throw new Error('Invalid import data format');
                }

                if (merge) {
                    // Merge with existing data
                    const existingData = await this.getActivityData();
                    const mergedData = this._mergeActivityData(existingData, importData.activityData);
                    await chrome.storage.local.set({ [this.KEYS.ACTIVITY_DATA]: mergedData });
                } else {
                    // Replace existing data
                    await chrome.storage.local.set({ [this.KEYS.ACTIVITY_DATA]: importData.activityData });
                }

                return true;
            } catch (error) {
                console.error('Error importing data:', error);
                return false;
            }
        },

        /**
         * Merge two activity data arrays, avoiding duplicates
         * @private
         */
        _mergeActivityData(existing, imported) {
            const merged = [...existing];
            const existingTimestamps = new Set(existing.map(chunk => chunk.timestamp));

            // Add imported chunks that don't exist
            for (const chunk of imported) {
                if (!existingTimestamps.has(chunk.timestamp)) {
                    merged.push(chunk);
                } else {
                    // If timestamp exists, keep the one with higher activity score (more complete data)
                    const existingIndex = merged.findIndex(c => c.timestamp === chunk.timestamp);
                    if (chunk.activityScore > merged[existingIndex].activityScore) {
                        merged[existingIndex] = chunk;
                    }
                }
            }

            // Sort by timestamp
            merged.sort((a, b) => a.timestamp - b.timestamp);

            return merged;
        },

    /**
     * Clear all activity data
     */
    async clearAllData() {
            try {
                await chrome.storage.local.remove(this.KEYS.ACTIVITY_DATA);
                await chrome.storage.local.remove(this.KEYS.CURRENT_CHUNK);
                return true;
            } catch (error) {
                console.error('Error clearing data:', error);
                return false;
            }
        },

    /**
     * Get current chunk being tracked
     */
    async getCurrentChunk() {
            try {
                const result = await chrome.storage.local.get(this.KEYS.CURRENT_CHUNK);
                return result[this.KEYS.CURRENT_CHUNK] || null;
            } catch (error) {
                console.error('Error getting current chunk:', error);
                return null;
            }
        },

    /**
     * Save current chunk being tracked
     */
    async saveCurrentChunk(chunk) {
            try {
                await chrome.storage.local.set({ [this.KEYS.CURRENT_CHUNK]: chunk });
                return true;
            } catch (error) {
                console.error('Error saving current chunk:', error);
                return false;
            }
        }
    };

    // Make available globally
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = StorageManager;
    }
